import * as childProcess from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";

type Case = {
  inputRel: string;
};

// Some Graph::Easy 0.76 as_graphviz fixtures trigger known upstream crashes.
// Example: Graph::Easy::As_graphviz::_generate_group_edge has a TODO noting it
// fails for empty groups, and `t/in/0_empty_groups.txt` hits that path.
//
// For these, Perl is not a usable oracle (no stable output), so we skip them and
// continue validating parity for the supported cases.
const PERL_KNOWN_BROKEN_GRAPHVIZ_INPUTS = new Set<string>(["t/in/0_empty_groups.txt"]);

function parseArgs(argv: string[]): {
  maxCases?: number;
  maxFailures: number;
  failFast: boolean;
  only?: string;
  exclude?: string;
} {
  const res: {
    maxCases?: number;
    maxFailures: number;
    failFast: boolean;
    only?: string;
    exclude?: string;
  } = {
    maxFailures: 20,
    failFast: false,
  };

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--fail-fast") {
      res.failFast = true;
      continue;
    }

    if (a === "--max-cases") {
      const v = argv[i + 1];
      if (!v) throw new Error("--max-cases requires a value");
      res.maxCases = Number(v);
      if (!Number.isFinite(res.maxCases) || res.maxCases <= 0) {
        throw new Error("--max-cases must be a positive number");
      }
      i++;
      continue;
    }

    if (a === "--max-failures") {
      const v = argv[i + 1];
      if (!v) throw new Error("--max-failures requires a value");
      res.maxFailures = Number(v);
      if (!Number.isFinite(res.maxFailures) || res.maxFailures <= 0) {
        throw new Error("--max-failures must be a positive number");
      }
      i++;
      continue;
    }

    if (a === "--only") {
      const v = argv[i + 1];
      if (!v) throw new Error("--only requires a value");
      res.only = v;
      i++;
      continue;
    }

    if (a === "--exclude") {
      const v = argv[i + 1];
      if (!v) throw new Error("--exclude requires a value");
      res.exclude = v;
      i++;
      continue;
    }

    throw new Error(`Unknown arg: ${a}`);
  }

  return res;
}

function walkInputs(inputsRoot: string): string[] {
  const out: string[] = [];

  const walk = (absDir: string, relDirPosix: string): void => {
    const entries = fs.readdirSync(absDir, { withFileTypes: true });
    for (const e of entries) {
      if (e.name.startsWith(".")) continue;
      const abs = path.join(absDir, e.name);
      const rel = relDirPosix ? path.posix.join(relDirPosix, e.name) : e.name;

      if (e.isDirectory()) {
        walk(abs, rel);
        continue;
      }

      if (!/\.(txt|dot|gdl)$/.test(e.name)) continue;
      out.push(rel);
    }
  };

  walk(inputsRoot, "");
  out.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
  return out;
}

function stripGeneratedBanner(text: string): string {
  // Perl as_graphviz emits a non-deterministic banner like:
  // "  // Generated by Graph::Easy 0.76 at <localtime>"
  // Normalize it away in both outputs for stable comparisons.
  return text.replace(/^\s*\/\/ Generated by Graph::Easy.*\r?\n/m, "");
}

function normalizeTopLevelClusterOrder(text: string): string {
  // Graph::Easy 0.76 As_graphviz outputs groups via a perl hash iteration order
  // that can vary across runs (hash seed). To keep comparisons stable and focused
  // on semantic output, normalize the ordering of *top-level* `subgraph "clusterN"`
  // blocks by sorting them by cluster id.
  const input = text.replace(/\r\n?/g, "\n");
  const hasTrailingNewline = input.endsWith("\n");

  const lines = input.split("\n");

  const firstIdx = lines.findIndex((l) => l.startsWith('  subgraph "cluster'));
  if (firstIdx === -1) return text;

  // Collect consecutive top-level cluster blocks.
  const prefix = lines.slice(0, firstIdx);
  const blocks: Array<{ clusterId: number; lines: string[] }> = [];

  let i = firstIdx;
  while (i < lines.length && lines[i].startsWith('  subgraph "cluster')) {
    const header = lines[i];
    const m = /subgraph\s+"cluster(\d+)"\s*\{/.exec(header);
    const clusterId = m ? Number(m[1]) : Number.NaN;

    const start = i;
    let depth = 0;
    while (i < lines.length) {
      const line = lines[i];
      for (const ch of line) {
        if (ch === "{") depth++;
        else if (ch === "}") depth--;
      }
      i++;
      if (depth === 0) break;
    }

    blocks.push({ clusterId, lines: lines.slice(start, i) });

    // Stop if the next non-empty line isn't another top-level subgraph.
    // (In Graph::Easy output, clusters appear contiguously before edges.)
    while (i < lines.length && lines[i] === "") {
      // Preserve blank lines in the suffix, not attached to the block.
      break;
    }

    if (i >= lines.length) break;
    if (!lines[i].startsWith('  subgraph "cluster')) break;
  }

  const suffix = lines.slice(i);

  const sorted = blocks
    .slice()
    .sort((a, b) => (a.clusterId || 0) - (b.clusterId || 0))
    .flatMap((b) => b.lines);

  const out = [...prefix, ...sorted, ...suffix].join("\n");
  return hasTrailingNewline && !out.endsWith("\n") ? out + "\n" : out;
}

function normalizeGraphvizOutput(text: string): string {
  const noBanner = stripGeneratedBanner(text);
  return normalizeTopLevelClusterOrder(noBanner);
}

function firstDiffIndex(a: string, b: string): number {
  const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) {
    if (a.charCodeAt(i) !== b.charCodeAt(i)) return i;
  }
  return a.length === b.length ? -1 : n;
}

function lineColAt(text: string, idx: number): { line: number; col: number } {
  let line = 1;
  let col = 1;

  for (let i = 0; i < idx && i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (ch === 10) {
      line++;
      col = 1;
    } else {
      col++;
    }
  }

  return { line, col };
}

function runPerlAsGraphviz(repoRoot: string, inputPath: string): childProcess.SpawnSyncReturns<string> {
  const lib = path.join(repoRoot, "Graph-Easy-0.76", "lib");

  const perlCode =
    `use strict; use warnings; use utf8; use Graph::Easy;\n` +
    `binmode STDOUT, ':encoding(UTF-8)';\n` +
    `my $file = shift; open my $fh, '<:encoding(UTF-8)', $file or die $!; local $/; my $txt = <$fh>; close $fh;\n` +
    `my $g = Graph::Easy->new($txt); die $g->error if $g->error;\n` +
    `print $g->as_graphviz();`;

  return childProcess.spawnSync("perl", ["-I", lib, "-MGraph::Easy", "-e", perlCode, inputPath], {
    encoding: "utf8",
    maxBuffer: 20 * 1024 * 1024,
  });
}

function main(): void {
  const { maxCases, maxFailures, failFast, only, exclude } = parseArgs(process.argv.slice(2));

  const repoRoot = process.cwd();
  const inputsRoot = path.join(repoRoot, "Graph-Easy-0.76", "t", "in");
  const asGraphvizJs = path.join(repoRoot, "dist", "examples", "as_graphviz.js");

  const cases: Case[] = walkInputs(inputsRoot).map((rel) => ({ inputRel: path.posix.join("t/in", rel) }));

  let pass = 0;
  let fail = 0;
  let skip = 0;

  const limitCases = maxCases ?? cases.length;

  for (let i = 0; i < cases.length && i < limitCases; i++) {
    const c = cases[i];

    if (only && !c.inputRel.includes(only)) continue;
    if (exclude && c.inputRel.includes(exclude)) continue;

    const inputPath = path.join(repoRoot, "Graph-Easy-0.76", c.inputRel);

    const perl = runPerlAsGraphviz(repoRoot, inputPath);
    if (perl.status !== 0) {
      if (PERL_KNOWN_BROKEN_GRAPHVIZ_INPUTS.has(c.inputRel)) {
        skip++;
        process.stderr.write(`[SKIP:perl] ${c.inputRel} (exit=${perl.status})\n`);
        continue;
      }

      fail++;
      const stderr = perl.stderr ?? "";
      process.stderr.write(
        `[FAIL:perl] ${c.inputRel} (exit=${perl.status})\n` +
          (stderr ? stderr.split(/\r?\n/).slice(0, 20).join("\n") + "\n" : "")
      );

      if (failFast || fail >= maxFailures) break;
      continue;
    }

    const expected = normalizeGraphvizOutput(perl.stdout ?? "");

    const run = childProcess.spawnSync(process.execPath, [asGraphvizJs, inputPath], {
      encoding: "utf8",
      maxBuffer: 20 * 1024 * 1024,
    });

    if (run.status !== 0) {
      fail++;
      const stderr = run.stderr ?? "";
      process.stderr.write(
        `[FAIL:runtime] ${c.inputRel} (exit=${run.status})\n` +
          (stderr ? stderr.split(/\r?\n/).slice(0, 20).join("\n") + "\n" : "")
      );

      if (failFast || fail >= maxFailures) break;
      continue;
    }

    const stdout = normalizeGraphvizOutput(run.stdout ?? "");

    if (stdout === expected) {
      pass++;
      continue;
    }

    fail++;
    const idx = firstDiffIndex(stdout, expected);
    const pos = idx === -1 ? { line: 1, col: 1 } : lineColAt(expected, idx);
    process.stderr.write(`[FAIL:diff] ${c.inputRel} (first mismatch at line ${pos.line}, col ${pos.col})\n`);

    if (failFast || fail >= maxFailures) break;
  }

  process.stdout.write(`pass=${pass} fail=${fail} skip=${skip} (maxFailures=${maxFailures})\n`);
  process.exitCode = fail === 0 ? 0 : 1;
}

try {
  main();
} catch (err) {
  const msg = err instanceof Error ? err.stack ?? err.message : String(err);
  process.stderr.write(msg + "\n");
  process.exitCode = 1;
}
